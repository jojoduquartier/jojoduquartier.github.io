{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Josiah's Python Code Snippets About me My name is Josiah Hounyo and I am Data Scientist with a background in Mathematics. I have a B.S. from The Ohio State University and a Professional masters from Michigan State. I love coding in general and python is my main go to language. I learned Haskell before python and although I never use Haskell, it is the programming language I love the most. Project Intent I use Python on a daily basis for both work and personal purposes. Every once in a while I come up with reusable code that I end up using for multiple projects. Sometimes these bits of code prove useful for colleagues and friends. I have benefitted from many people sharing their code snippets online so this is a way for paying it forward. The snippets shared here are meant to be very simple and applicable in different situation; they are not data-science specific. If you have any suggestions or find issues with the snippets please provide information by commenting on the page; I welcome every opportunity to learn and improve. Connect GitHub","title":"Home"},{"location":"#welcome-to-josiahs-python-code-snippets","text":"","title":"Welcome to Josiah's Python Code Snippets"},{"location":"#about-me","text":"My name is Josiah Hounyo and I am Data Scientist with a background in Mathematics. I have a B.S. from The Ohio State University and a Professional masters from Michigan State. I love coding in general and python is my main go to language. I learned Haskell before python and although I never use Haskell, it is the programming language I love the most.","title":"About me"},{"location":"#project-intent","text":"I use Python on a daily basis for both work and personal purposes. Every once in a while I come up with reusable code that I end up using for multiple projects. Sometimes these bits of code prove useful for colleagues and friends. I have benefitted from many people sharing their code snippets online so this is a way for paying it forward. The snippets shared here are meant to be very simple and applicable in different situation; they are not data-science specific. If you have any suggestions or find issues with the snippets please provide information by commenting on the page; I welcome every opportunity to learn and improve.","title":"Project Intent"},{"location":"#connect","text":"GitHub","title":"Connect"},{"location":"snippets/close_db_connections/","text":"Close DB Connections Nearly every data scientist work(ed)s on a project that requires connection to a database (DB). It is always a good idea to close DB connections after reading/writing the data you need. SQLAlchemy has a dispose method for DB engines as well as objects to handle transactions that release resources automatically. Every DB API in python has a method to close connections; CXOracle has a close method for example. When dealing with different databases, in order to not repeat myself and make sure I always close connections, I tend to use a snippet like this: The Snippet import sqlite3 import contextlib from sqlalchemy import create_engine @contextlib . contextmanager def db_connections (): # the engines created here could all be Oracle, MSSql, Snowflake etc. try : # connect to some in-memory engine sales_db = create_engine ( 'sqlite:///' ) # another in-memory engine manufacturing_db = sqlite3 . connect ( ':memory:' ) # yield results yield sales_db , manufacturing_db except Exception as e : # handle exceptions etc pass finally : sales_db . dispose () manufacturing_db . close () Context Managers are very useful in python when it comes to providing and releasing resources (like opening a file to read from and releasing it for the next task). There is a utility decorator that makes it easy to turn your existing functions into context-managers and that is what I used for this snippet. An Example with db_connections () as ( sales_db , manufacturing_db ): # do something like # pd.read_sql(..., sales_db) # pd.read_sql(..., manufacturing_db) pass Thank you!","title":"Close DB Connections"},{"location":"snippets/close_db_connections/#close-db-connections","text":"Nearly every data scientist work(ed)s on a project that requires connection to a database (DB). It is always a good idea to close DB connections after reading/writing the data you need. SQLAlchemy has a dispose method for DB engines as well as objects to handle transactions that release resources automatically. Every DB API in python has a method to close connections; CXOracle has a close method for example. When dealing with different databases, in order to not repeat myself and make sure I always close connections, I tend to use a snippet like this:","title":"Close DB Connections"},{"location":"snippets/close_db_connections/#the-snippet","text":"import sqlite3 import contextlib from sqlalchemy import create_engine @contextlib . contextmanager def db_connections (): # the engines created here could all be Oracle, MSSql, Snowflake etc. try : # connect to some in-memory engine sales_db = create_engine ( 'sqlite:///' ) # another in-memory engine manufacturing_db = sqlite3 . connect ( ':memory:' ) # yield results yield sales_db , manufacturing_db except Exception as e : # handle exceptions etc pass finally : sales_db . dispose () manufacturing_db . close () Context Managers are very useful in python when it comes to providing and releasing resources (like opening a file to read from and releasing it for the next task). There is a utility decorator that makes it easy to turn your existing functions into context-managers and that is what I used for this snippet.","title":"The Snippet"},{"location":"snippets/close_db_connections/#an-example","text":"with db_connections () as ( sales_db , manufacturing_db ): # do something like # pd.read_sql(..., sales_db) # pd.read_sql(..., manufacturing_db) pass Thank you!","title":"An Example"},{"location":"snippets/logging_decorator/","text":"Try - Catch Exception Handling on Multiple Functions I often find myself splitting my code across modules each with their functions that I use in some sort of a main script or function for my projects. I like to log the progress of my code when it is deployed and I also like to keep one single log per project (when this makes sense obviously). When a function I imported is being used by the main function/script, I try to wrap it in some try/except (see below code block) block to make sure I catch any unexpected failure. try : # call the function except : # do something and log it finally : # release resources In the spirit of DRY , I started using this simple decorator for my functions so that I can avoid wrapping all functions with the try/except block. The Snippet from functools import wraps from loguru._logger import Logger def try_catch ( logger : Logger ): \"\"\" Decorate a function with the module logger to not just track errors but catch errors on any function without repeating a try:...except:... block :param logger: a logger object, could be a python native logger as well \"\"\" def proper_decorator ( func ): @wraps ( func ) def wrapper ( * args , ** kwargs ): try : output = func ( * args , ** kwargs ) return output except Exception as e : logger . exception ( f \"Failure in { func . __name__ } \" ) raise e return wrapper return proper_decorator I use the wraps decorator from functools so that I can use the function's actual name in my traceback. An Example from loguru import logger # set the logger handle etc. here @try_catch ( logger ) def my_function ( numpy_array , user_constant ): \"\"\" Just a 1-D Numpy arrays divided by some constant. P.S. this example is designed to fail with constant 0 i.e. I omit the ZeroDivision check \"\"\" reciprocal = 1 / user_constant return reciprocal * numpy_array # try import numpy as np my_function ( np . array ([ 0 , 1 ]), 2 ) my_function ( np . array ([ 0 , 1 ]), 0 ) # Inspect the log and traceback When my_function fails with user providing 0 for the constant, I want to see the full traceback and the decorator handles that. I would suggest using this for functions dealing with databases or external communication that can easily fail unexpectedly. Thank you!","title":"Try/Catch Decorator"},{"location":"snippets/logging_decorator/#try-catch","text":"","title":"Try - Catch"},{"location":"snippets/logging_decorator/#exception-handling-on-multiple-functions","text":"I often find myself splitting my code across modules each with their functions that I use in some sort of a main script or function for my projects. I like to log the progress of my code when it is deployed and I also like to keep one single log per project (when this makes sense obviously). When a function I imported is being used by the main function/script, I try to wrap it in some try/except (see below code block) block to make sure I catch any unexpected failure. try : # call the function except : # do something and log it finally : # release resources In the spirit of DRY , I started using this simple decorator for my functions so that I can avoid wrapping all functions with the try/except block.","title":"Exception Handling on Multiple Functions"},{"location":"snippets/logging_decorator/#the-snippet","text":"from functools import wraps from loguru._logger import Logger def try_catch ( logger : Logger ): \"\"\" Decorate a function with the module logger to not just track errors but catch errors on any function without repeating a try:...except:... block :param logger: a logger object, could be a python native logger as well \"\"\" def proper_decorator ( func ): @wraps ( func ) def wrapper ( * args , ** kwargs ): try : output = func ( * args , ** kwargs ) return output except Exception as e : logger . exception ( f \"Failure in { func . __name__ } \" ) raise e return wrapper return proper_decorator I use the wraps decorator from functools so that I can use the function's actual name in my traceback.","title":"The Snippet"},{"location":"snippets/logging_decorator/#an-example","text":"from loguru import logger # set the logger handle etc. here @try_catch ( logger ) def my_function ( numpy_array , user_constant ): \"\"\" Just a 1-D Numpy arrays divided by some constant. P.S. this example is designed to fail with constant 0 i.e. I omit the ZeroDivision check \"\"\" reciprocal = 1 / user_constant return reciprocal * numpy_array # try import numpy as np my_function ( np . array ([ 0 , 1 ]), 2 ) my_function ( np . array ([ 0 , 1 ]), 0 ) # Inspect the log and traceback When my_function fails with user providing 0 for the constant, I want to see the full traceback and the decorator handles that. I would suggest using this for functions dealing with databases or external communication that can easily fail unexpectedly. Thank you!","title":"An Example"}]}